// #define ENCODER_OPTIMIZE_INTERRUPTS
#include <Encoder.h>

// The types of the position, velocity, and acceleration measurements
// (respectively)
#define P_type long int
#define V_type float
#define A_type float

#define DATA_SIZE                                                              \
    ((sizeof(P_type) + sizeof(V_type) + sizeof(A_type)) / sizeof(byte))
        
// The size of the message in bytes
#define MSG_SIZE                                                               \
    ((DATA_SIZE + 3 /*P,V,A*/ + 1 /*L|R*/) * 2 /*BOTH*/ + 1 /*NULL*/)
        
// The rate of communication
#define BAUD_RATE 115200

// Goes in setup() somewhere
#define SETUP_CONNECTION Serial.begin(BAUD_RATE)
        
#define AVG( a, b ) ((float(a) + float(b))/2.0)

// Basic structure for organizing measurement data

byte * buf = new byte[MSG_SIZE];

P_type L_position   = 0;
V_type L_velocity   = 0;
A_type L_xlr8tion   = 0;

P_type R_position   = 0;
V_type R_velocity   = 0;
A_type R_xlr8tion   = 0;

/*Sourced from-- http://www.pololu.com/product/1217  */
const int linear_rez = 3; // mm == 1/8 inch
const int count_per_rev = 48;

const int SEC = 60;
const int x = 2;
const int N = 100;

/*number of pulses generated by the encoder per shaft revolution*/
const int encoder_pulse = 48;

long positionLeft  = -999;
long positionRight = -999;



int PowerMotorL = 10;
int PowerEncL   = 11;
int PowerMotorR = 12;
int PowerEncR   = 13;

const int LeftEncA = 2;// must be capable of interrupt
const int LeftEncB = 5;

const int RightEncA = 3;// must be capable of interrupt
const int RightEncB = 6;

const float cycle_delay = 20;//micoseconds


Encoder MotorLeft(  LeftEncA , LeftEncB  );
Encoder MotorRight( RightEncA, RightEncB );

void setup()
{
    /*
    // set up a test motor
    pinMode( PowerMotorR, OUTPUT );
    pinMode( PowerEncR, OUTPUT );
    */
    
    // Setup the encoder
    pinMode( LeftEncA , INPUT );
    pinMode( LeftEncB , INPUT );
    pinMode( RightEncA, INPUT );
    pinMode( RightEncB, INPUT );
    
    // initilize positions to zero.
    MotorLeft.write(  0 );
    MotorRight.write( 0 );
    
    SETUP_CONNECTION;
    
    /*
    int velocity();
    int acceleration();
    int positionm();
    void UART();
    */
}

void loop()
{
    // Get new position data
    P_type  L_pos_new , R_pos_new;
    L_pos_new = digitalRead( MotorLeft.read()  );
    R_pos_new = digitalRead( MotorRight.read() );
    
    // Calculate new velocity data
    V_type  L_vel_new , R_vel_new;
    L_vel_new = (L_position - L_pos_new)/cycle_delay;
    R_vel_new = (R_position - R_pos_new)/cycle_delay;
    
    // Save position data
    L_position = L_pos_new;
    R_position = R_pos_new;
    
    // Calculate (and save) new acceleration data
    L_xlr8tion = (L_velocity - L_vel_new)/cycle_delay;
    R_xlr8tion = (R_velocity - R_vel_new)/cycle_delay;
    
    // Save velocity data
    L_velocity = L_vel_new;
    R_velocity = R_vel_new;
    
    if( ( L_position > count_per_rev || L_position < 0-count_per_rev ) &&
        ( R_position > count_per_rev || R_position < 0-count_per_rev ) &&
        ( L_velocity < 0.1f && L_velocity > -0.1f  ) &&
        ( R_velocity < 0.1f && R_velocity > -0.1f  ) )
    {
        MotorLeft.write(  0 );
        MotorRight.write( 0 );
    }
    
    
    
    send_data();
}

/* Parses the value pointed to by _data into bytes and fills the _array
    with them starting with the index of the pointer. The number of
    bytes parsed whould be equal to sizeof(_data)/sizeof(byte), which
    should be equal to _num_bytes. The pointer returns is to the index
    of _array which immediately follows the last byte of _data written.
 */
byte * fill_byte( byte * _array, void * _data, size_t _num_bytes )
{
    byte * _tmp = ( byte * )_data;
    for( size_t i = 0; i < _num_bytes; i++ )
    {
        ( *_array++ ) = ( *_tmp++ );
    }
    return _array;
}

/* Fills out the global buffer with the provided data and sends it via
    Serial.write() to the receiver. The buffer is also filled with index
    markers to delineate the measurements and each wheel.
 */
int send_data() //( data  _L/*left wheel*/, data  _R/*right wheel*/)
{
    byte * _tmp = buf;

    *_tmp++ = 'L';
    *_tmp++ = 'P';
    _tmp = fill_byte( _tmp, &( L_position ), sizeof( P_type ) / sizeof( byte ) );
    *_tmp++ = 'V';
    _tmp = fill_byte( _tmp, &( L_velocity ), sizeof( V_type ) / sizeof( byte ) );
    *_tmp++ = 'A';
    _tmp = fill_byte( _tmp, &( L_xlr8tion ), sizeof( A_type ) / sizeof( byte ) );

    *_tmp++ = 'R';
    *_tmp++ = 'P';
    _tmp = fill_byte( _tmp, &( R_position ), sizeof( P_type ) / sizeof( byte ) );
    *_tmp++ = 'V';
    _tmp = fill_byte( _tmp, &( R_velocity ), sizeof( V_type ) / sizeof( byte ) );
    *_tmp++ = 'A';
    _tmp = fill_byte( _tmp, &( R_xlr8tion ), sizeof( A_type ) / sizeof( byte ) );

    *_tmp++ = '\0';

    // Serial.write(buf, MSG_SIZE);
    return 0;
}

